
\sloppy
{\fontsize{18pt}{18pt}\selectfont Clone Opration \\} \par
\begin{itemize}
	\item Logo
\end{itemize}
\begin{figure}[ht]
	\centerline{\includegraphics[width=0.70\textwidth]{figures/logo}}
	\caption{Logo}
	\label{Logo}
\end{figure}
\section{Clone Opration}
\vspace{14pt}
\noindent 
{\fontsize{16pt}{16pt}\selectfont cara install \\} \par
\vspace{16pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Lakukan inisialisasi dengan mengetikkan perintah berikut pada Git Bash tadi \\} \par
\begin{itemize}
	\item git init
\end{itemize}
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Perintah tersebut akan membuat sebuah repository lokal untuk proyek kita \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Langkah berikutnya adalah memasukkan file-file source code serta folder pada proyek kedalam staging area, yaitu suatu kondisi dimana file serta folder source code dimasukkan ke dalam repository namun dalam keadaan temporary, belum disimpan. Untuk melakukannya gunakan perintah berikut. \\} \par
\begin{itemize}
	\item git add *
\end{itemize}
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Perintah tersebut akan memasukkan seluruh file dan folder yang ada pada folder ProyekPHP. Jika ingin memasukkan satu persatu cukup tuliskan nama file lengkap dengan ekstensinya atau nama folder jika hanya ingin menambahkan satu folder \\} \par
\begin{itemize}
	\item git add index.php 
\end{itemize}
\begin{itemize}
	\item git add nama folder 
\end{itemize}

\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Setelah itu kita siap untuk menyimpan source code kita kedalam repository. Ketikkan perintah berikut \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont git commit -m (dan teks penambahan data atau quots apa saja) \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Perintah diatas akan menyimpan source code kita sekaligus memberikan catatan supaya mudah kita ingat \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Sekarang login ke Github.com dan buatlah sebuah repository baru dengan mengeklik tombol yang terletak pada kanan atas. Perhatikan gambar berikut \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Buat repository dengan nama  $ " $PHPKeren $ " $ misalnya \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Sekarang kita bisa mengakses remote repository dengan url \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Kembali ke Git Bash. Tambahkan remote repository yang barusan kita buat supaya proyek kita bisa diupload. Berikut perintahnya \\} \par
\begin{itemize}
	\item git remote add origin (link github yang di copy ssh nya)
\end{itemize}

\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Selanjutnya kita download terlebih dahulu file readme yang ada secara default ketika kita membuat repository di github dengan mengetikkan perintah \\} \par
\begin{itemize}
	\item git pull origin master
\end{itemize}

\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Maka file readme.md akan berada pada folder proyek kita \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Terakhir adalah mengupload ke Github dengan perintah \\} \par
\begin{itemize}
	\item git push origin master
\end{itemize}

\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont masukkan username serta password jika diminta \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont Cek pada github maka file ktia sudah berada disana \\} \par
\vspace{14pt}
\subsection {Memantau berkas baru}
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Untuk mulai memantau berkas baru, Anda menggunakan perintah $  $git add. Untuk mulai memantau berkas README tadi, Anda menjalankannya seperti berikut: \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \$  $ git add README \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Jika Anda menjalankan perintah $  $status $  $lagi, Anda akan melihat bahwa berkas README Anda sekarang sudah terpantau dan sudah masuk ke dalam area stage: \\} \par
\begin{verbatim}

 git status \\} 
 On branch master \\}
 Changes to be committed:
 (use "git reset HEAD <file>..." to unstage)
 new~file:~  README \\}
 
 \end{verbatim}
 
\noindent 
{\fontsize{14pt}{14pt}\selectfont Anda dapat mengatakan bahwa berkas tersebut berada di dalam area stage karena tertulis di bawah judul "Changes to be committed". Jika Anda melakukan commit pada saat ini, versi berkas pada saat Anda menjalankan $  $git add $  $inilah yang akan dimasukkan ke dalam sejarah snapshot. Anda mungkin ingat bahwa ketika Anda menjalankan $  $git init $  $sebelumnya, Anda melanjutkannya dengan $  $git add (nama berkas) $  $- yang akan mulai dipantau di direktori Anda. Perintah $  $git add $  $ini mengambil alamat dari berkas ataupun direktori; jika sebuah direktori, perintah tersebut akan menambahkan seluruh berkas yang berada di dalam direktori secara rekursif. \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont Memasukan berkas baru di edit ke dalam stage yang dibuat \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Mari kita ubah sebuah berkas yang sudah terpantau. Jika Anda mengubah berkas yang sebelumnya terpantau bernama $  $benchmarks.rb $  $dan kemudian menjalankan perintah $  $status $  $lagi, Anda akan mendapatkan keluaran kurang lebih seperti ini: \\} \par

\begin{verbatim}
	

git status
On branch master
Changes to be committed:
(use "git reset HEAD <file>..." to unstage)
new~file:~  README \\}
Changes not staged for commit:
(use "git add <file>..." to update what will be committed)
~~~modified:~  benchmarks.rb

\end{verbatim}
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Berkas benchmarks.rb terlihat di bawah bagian yang bernama "Changes not staged for commit" - yang berarti bahwa sebuah berkas terpantau telah berubah di dalam direktori kerja namun belum masuk ke area stage. Untuk memasukkannya ke area stage, Anda menjalankan perintah $  $git add $  $(perintah ini adalah perintah multiguna - Anda menggunakannya untuk mulai memantau berkas baru, untuk memasukkannya ke area stage, dan untuk melakukan hal lain seperti menandai berkas terkonflik menjadi terpecahkan). Mari kita sekarang jalankan $  $git add $  $untuk memasukkan berkas rb ke dalam area stage, dan jalankan $  $git status $  $lagi: \\} \par
\begin{verbatim}
	

 git add benchmarks.rb
 git status
 On branch master \\}
 Changes to be committed:
 (use "git reset HEAD <file>..." to unstage)
 new~file:~  README
 modified:~  benchmarks.rb
\end{verbatim}

\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Kedua file sekarang berada di area stage dan akan masuk ke dalam commit Anda berikutnya. Pada saat ini, semisal Anda teringat satu perubahan yang Anda ingin buat di benchmarks.rb sebelum Anda lakukan commit. Anda buka berkas tersebut kembali dan melakukan perubahan tersebut, dan Anda siap untuk melakukan commit. Namun, mari kita coba jalankan $  $git status $  $kembali: \\} \par

\begin{verbatim}

vim benchmarks.rb
git status
On branch master
Changes to be committed:
(use "git reset HEAD <file>..." to unstage)

new~file:~  README
modified:~  benchmarks.rb
Changes not staged for commit: 
(use "git add <file>..." to update what will be committed)
modified:~  benchmarks.rb

\end{verbatim}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Git memasukkan berkas ke area stage tepat seperti ketika Anda menjalankan perintah $  $git add. Jika Anda commit sekarang, versi benchmarks.rb pada saat Anda terakhir lakukan perintah $  $git add-lah yang akan masuk ke dalam commit, bukan versi berkas yang saat ini terlihat di direktori kerja Anda ketika Anda menjalankan $  $git commit. Jika Anda mengubah sebuah berkas setelah Anda menjalankan $  $git add, Anda harus menjalankan $  $git add $  $kembali untuk memasukkan versi berkas terakhir ke dalam area stage: \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \$  $ git add benchmarks.rb \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \$  $ git status \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ On branch master \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ Changes to be committed: \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $~~ (use "git reset HEAD <file>..." to unstage) \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $~~ new~file:~  README \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $~~~modified:~  benchmarks.rb \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ \\} \par
\vspace{14pt}
\subsection {Mengabaikan berkas}
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Terkadang, Anda memiliki sekumpulan berkas yang Anda tidak ingin Git tambahkan secara otomatis atau bahkan terlihat sebagai tak-terpantau. Biasanya berkas hasil keluaran seperti berkas log atau berkas yang dihasilkan oleh sistem build Anda. Dalam kasus ini, Anda dapat membuat sebuah berkas bernama .gitignore yang berisi pola dari berkas terabaikan. Berikut adalah sebuah contoh isi dari berkas .gitignore: \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \$  $ cat .gitignore \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont *.[oa] \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont * $  \sim  $ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont Baris pertama memberitahu Git untuk mengabaikan semua file yang berakhiran .o atau .a - berkas object dan arsip yang mungkin dihasilkan dari kompilasi kode Anda. Baris kedua memberitahu Git untuk mengabaikan semua file yang berakhiran dengan sebuah tilde ( $  \sim  $), yang biasanya digunakan oleh banyak aplikasi olah-kata seperti Emacs untuk menandai berkas sementara. Anda juga dapat memasukkan direktori log, tmp ataupun pid; dokumentasi otomatis; dan lainnya. Menata berkas .gitignore sebelum Anda mulai bekerja secara umum merupakan ide yang baik sehingga Anda tidak secara tak-sengaja melakukan commit terhadap berkas yang sangat tidak Anda inginkan berada di dalam repositori Git. \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont Aturan untuk pola yang dapat Anda gunakan di dalam berkas .gitignore adalah sebagai berikut: \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Baris kosong atau baris dimulai dengan  $  \#  $ akan diabaikan. \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Pola glob standar dapat digunakan. \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont Anda dapat mengakhir pola dengan sebuah slash (/) untuk menandai sebuah direktori. \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont Anda dapat menegasikan sebuah pola dengan memulainya menggunakan karakter tanda seru (!). \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Pola Glob adalah seperti regular expression yang disederhanakan yang biasanya digunakan di shell. Sebuah asterisk (*) berarti 0 atau lebih karakter; $  $[abc] $  $terpasangkan dengan karakter apapun yang ditulis dalam kurung siku (dalam hal ini a, b, atau c); sebuah tanda tanya (?) terpasangkan dengan sebuah karakter; dan kurung siku yang melingkupi karakter yang terpisahkan dengan sebuah tanda hubung([0-9]) terpasangkan dengan karakter apapun yang berada diantaranya (dalam hal ini 0 hingga 9). \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Berikut adalah contoh lain dari isi berkas .gitignore: \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ sebuah komentar â€“ akan diabaikan \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ abaikan berkas .a \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont *.a \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ tapi pantau lib.a, walaupun Anda abaikan berkas .a di atas \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont !lib.a \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ hanya abaikan berkas TODO yang berada di rooto, bukan di subdir/TODO \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont /TODO \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ abaikan semua berkas di dalam direktori build/ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont build/ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ abaikan doc/notes.txt, tapi bukan doc/server/arch.txt \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont doc/*.txt \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont melihat perubahan di dalam stage dan di luar stage \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Jika perintah $  $git status $  $terlalu kabur untuk Anda - Anda ingin mengetahui secara pasti apa yang telah berubah, bukan hanya berkas mana yang berubah - Anda dapat menggunakan perintah $  $git diff. Kita akan bahas $  $git diff $  $secara lebih detil nanti; namun Anda mungkin menggunakannya paling sering untuk menjawab 2 pertanyaan berikut: Apa yang Anda ubah tapi belum dimasukkan ke area stage? Dan apa yang telah Anda ubah yang akan segera Anda commit? Walaupun $  $git status $  $menjawab pertanyaan tersebut secara umum, $  $git diff $  $menunjukkan kepada Anda dengan tepat baris yang ditambahkan dan dibuang - dalam bentuk patch-nya. \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont Mari kita anggap Anda mengubah dan memasukkan berkas README ke area stage lagi dan kemudian mengubah berkas benchmarks.rb tanpa memasukkannya ke area stage. Jika Anda jalankan perintah $  $status $  $Anda, Anda akan sekali lagi melihat keluaran seperti berikut: \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \$  $ git status \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ On branch master \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ Changes to be committed: \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $~~ (use "git reset HEAD <file>..." to unstage) \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $~~ new~file:~  README \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ Changes not staged for commit: \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $~~ (use "git add <file>..." to update what will be committed) \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $~~~modified:~  benchmarks.rb \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont Untuk melihat apa yang Anda telah ubah namun belum masuk ke area stage, ketikkan $  $git diff $  $tanpa argumen lainnya. \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \$  $ git diff \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont diff --git a/benchmarks.rb b/benchmarks.rb \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont index 3cb747f..da65585 100644 \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont --- a/benchmarks.rb \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont +++ b/benchmarks.rb \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont @@ -36,6 +36,10 @@ def main \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont @commit.parents[0].parents[0].parents[0] \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont end \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont +~~~~~~~ run $  \_  $code(x, 'commits 1') do \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont +~~~~~~~~~ git.commits.size \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont +~~~~~~~ end \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont + \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont run $  \_  $code(x, 'commits 2') do \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont log = git.commits('master', 15) \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont log.size \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Perintah di atas membandingkan apa yang ada di direktori kerja Anda dengan apa yang ada di area stage. Hasilnya memberitahu Anda bahwa perubahan yang Anda ubah namun belum masuk ke area stage. \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Jika Anda ingin melihat apa yang telah Anda masukkan ke area stage yang nantinya akan masuk ke commit Anda berikutnya, Anda dapat menggunakan $  $git diff --cached. (Di Git versi 1.6.1 atau yang lebih tinggi, Anda dapat juga menggunakan $  $git diff --staged, yang mungkin lebih mudah untuk diingat). Perintah ini membandingkan area stage Anda dengan commit Anda terakhir: \\} \par
\begin{verbatim}

$ git diff --cached
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README2
@@ -0,0 +1,5 @@
+grit

\end{verbatim}
\noindent 
{\fontsize{14pt}{14pt}\selectfont + by Tom Preston-Werner, Chris Wanstrath \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont + http://github.com/mojombo/grit \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont + \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont +Grit is a Ruby library for extracting information from a Git repository \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont Satu hal penting yang harus dicatat adalah bahwa $  $git diff $  $saja tidak memperlihatkan semua perubahan yang telah Anda lakukan sejak terakhir Anda commit - hanya perubahan yang belum masuk ke area stage saja. Mungkin agak sedikit membingungkan, karena jika Anda telah memasukkan semua perubahan ke area stage, $  $git diff $  $akan memberikan keluaran kosong. \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont Sebagai contoh lain, jika Anda memasukkan berkas benchmarks.rb ke area stage dan kemudian meng-editnya, Anda dapat menggunakan $  $git diff $  $untuk melihat perubahan di berkas tersebut yang telah masuk ke area stage dan perubahan yang masih di luar area stage: \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \$  $ git add benchmarks.rb \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \$  $ echo ' $  \#  $ test line' >> benchmarks.rb \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \$  $ git status \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ On branch master \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ Changes to be committed: \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $~~~modified:~  benchmarks.rb \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ Changes not staged for commit: \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $~~~modified:~  benchmarks.rb \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont Sekarang Anda dapat menggunakan $  $git diff $  $untuk melihat apa saja yang masih belum dimasukkan ke area stage: \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \$  $ git diff \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont diff --git a/benchmarks.rb b/benchmarks.rb \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont index e445e28..86b2f7c 100644 \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont --- a/benchmarks.rb \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont +++ b/benchmarks.rb \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont @@ -127,3 +127,4 @@ end \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont main() \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ $  \#  $pp Grit::GitRuby.cache $  \_  $client.stats \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont + $  \#  $ test line \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont dan $  $git diff --cached $  $untuk melihat apa yang telah Anda masukkan ke area stage sejauh ini: \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \$  $ git diff --cached \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont diff --git a/benchmarks.rb b/benchmarks.rb \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont index 3cb747f..e445e28 100644 \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont --- a/benchmarks.rb \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont +++ b/benchmarks.rb \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont @@ -36,6 +36,10 @@ def main \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont @commit.parents[0].parents[0].parents[0] \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont end \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont +~~~~~~~ run $  \_  $code(x, 'commits 1') do \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont +~~~~~~~~~ git.commits.size \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont +~~~~~~~ end \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont + \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont run $  \_  $code(x, 'commits 2') do \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont log = git.commits('master', 15) \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont log.size \\} \par
\vspace{14pt}
\subsection {Comit perubahan atau yang telah di edit}
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Sekarang setelah area stage Anda tertata sebagaimana yang Anda inginkan, Anda dapat melakukan commit terhadap perubahan Anda. Ingat bahwa apapun yang masih di luar area stage - berkas apapun yang Anda telah buat atau ubah yang belum Anda jalankan $  $git add $  $terhadapnya sejak terakhir Anda edit - tidak akan masuk ke dalam commit ini. Perubahan tersebut akan tetap sebagai berkas terubah di cakram Anda. Dalam hal ini, saat terakhir Anda jalankan $  $git status, Anda telah melihat bahwa semuanya telah masuk ke stage, sehingga Anda siap untuk melakukan commit dari perubahan Anda. Cara termudah untuk melakukan commit adalah dengan mengetikkan $  $git commit: \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \$  $ git commit \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Dengan melakukan ini, aplikasi olahkata pilihan Anda akan terjalankan (Ini ditata oleh variabel lingkungan $  $ $  \$  $EDITOR $  $di shell Anda - biasanya vim atau emacs, walaupun Anda dapat mengkonfigurasinya dengan apapun yang Anda inginkan  \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ Please enter the commit message for your changes. Lines starting \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ with ' $  \#  $' will be ignored, and an empty message aborts the commit. \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ On branch master \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ Changes to be committed: \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $~~ (use "git reset HEAD <file>..." to unstage) \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $~~~~~~ new~file:~  README \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $~~~~~~~modified:~  benchmarks.rb \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \sim  $ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \sim  $ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \sim  $ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont ".git/COMMIT $  \_  $EDITMSG" 10L, 283C \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Anda dapat melihat bahwa pesan commit standar berisi keluaran terakhir dari perintah $  $git statusyang terkomentari dan sebuah baris kosong di bagian atas. Anda dapat membuang komentar-komentar ini dan mengetikkan pesan commit Anda, atau Anda dapat membiarkannya untuk membantu Anda mengingat apa yang akan Anda commit. (Untuk pengingat yang lebih eksplisit dari apa yang Anda ubah, Anda dapat menggunakan opsi $  $-v $  $di perintah $  $git commit. Melakukan hal ini akan membuat diff dari perubahan Anda di dalam olahkata sehingga Anda dapat melihat secara tepat apa yang telah Anda lakukan). Ketika Anda keluar dari olahkata, Git akan membuat commit Anda dengan pesan yang Anda buat (dengan bagian terkomentari dibuang). \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont Cara lainnya, Anda dapat mengetikkan pesan commit Anda sebaris denegan perintah $  $commit $  $dengan mencantumkannya setelah tanda -m seperti berikut: \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \$  $ git commit -m "Story 182: Fix benchmarks for speed" \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont [master]: created 463dc4f: "Fix benchmarks for speed" \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont 2 files changed, 3 insertions(+), 0 deletions(-) \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont create mode 100644 README \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Sekarang Anda telah membuat commit pertama Anda $  \sim  $ Anda dapat lihat bahwa commit tersebut telah memberi Anda beberapa keluaran tentang dirinya sendiri: cabang apa yang Anda jadikan target commit (master) berapa banyak berkas yang diubah, dan statistik tentang jumlah baris yang ditambah dan dibuang dalam commit tersebut. \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont Ingat bahwa commit merekam snapshot yang Anda telah tata di area stage. Apapun yang tidak Anda masukkan ke area stage akan tetap berada di tempatnya, tetap dalam keadaan terubah; Anda dapat melakukan commit lagi untuk memasukkannya ke dalam sejarah Anda. Setiap saat Anda melakukan sebuah commit, Anda merekamkan sebuah snapshot dari proyek Anda yang bisa Anda kembalikan atau Anda bandingkan nantinya. \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Melewatkan area stage \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont Walaupun dapat menjadi sangat berguna untuk menata commit tepat sebagaimana Anda inginkan, area stage terkadang sedikit lebih kompleks dibandingkan apa yang Anda butuhkan di dalam alurkerja Anda. Jika Anda ingin melewatkan area stage, Git menyediakan sebuah jalan pintas sederhana. Dengan memberikan opsi $  $-a $  $ke perintah $  $git commit $  $akan membuat Git secara otomatis menempatkan setiap berkas yang telah terpantau ke area stage sebelum melakukan commit, membuat Anda dapat melewatkan bagian $  $git add: \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \$  $ git status \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ On branch master \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ Changes not staged for commit: \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $~~~modified:~  benchmarks.rb \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \$  $ git commit -a -m 'added new benchmarks' \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont [master 83e38c7] added new benchmarks \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont 1 files changed, 5 insertions(+), 0 deletions(-) \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Perhatikan bagaimana Anda tidak perlu menjalankan $  $git add $  $terhadap berkas benchmarks.rb dalam hal ini sebelum Anda commit. \\} \par
\vspace{14pt}
\subsection {Menghapus berkas}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Untuk menghapus sebuah berkas dari Git, Anda harus menghapusnya dari berkas terpantau (lebih tepatnya, mengpus dari area stage) dan kemudian commit. Perintah $  $git rm $  $melakukan hal tadi dan juga menghapus berkas tersebut dari direktori kerja Anda sehingga Anda tidak melihatnya sebagai berkas yang tak terpantau nantinya. \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont Jika Anda hanya menghapus berkas dari direktori kerja Anda, berkas tersebut akan muncul di bagian "Changes not staged for commit" (yaitu, di luar area stage) dari keluaran $  $git status $  $Anda: \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \$  $ rm grit.gemspec \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \$  $ git status \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ On branch master \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ Changes not staged for commit: \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $~~ (use "git add/rm <file>..." to update what will be committed) \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $~~~~~~~deleted:~~  grit.gemspec \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont Kemudian, jika Anda jalankan $  $git rm, Git akan memasukkan penghapusan berkas tersebut ke area stage: \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \$  $ git rm grit.gemspec \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont rm 'grit.gemspec' \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \$  $ git status \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ On branch master \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ Changes to be committed: \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $~~ (use "git reset HEAD <file>..." to unstage) \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $~~~~~~~deleted:~~  grit.gemspec \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont Pada saat Anda commit nantinya, berkas tersebut akan hilang dan tidak lagi terpantau. Jika Anda mengubah berkas tersebut dan menambahkannya lagi ke index, Anda harus memaksa penghapusannya dengan menggunakan opsi $  $-f. Ini adalah fitur keamanan (safety) untuk mencegah ketidaksengajaan penghapusan terhadap data yang belum terekam di dalam snapshot dan tak dapat dikembalikan oleh Git. \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont Hal berguna lain yang Anda dapat lakukan adalah untuk tetap menyimpan berkas di direktori kerja tetapi menghapusnya dari area kerja. Dengan kata lain, Anda mungkin ingin tetap menyimpan berkas tersebut di dalam cakram keras tetapi tidak ingin Git untuk memantaunya lagi. Hal ini khususnya berguna jika Anda lupa untuk menambahkan sesuaitu ke berkas $  $.gitignore $  $Anda dan secara tak-sengaja menambahkannya, seperti sebuah berkas log yang besar, atau sekumpulan berkas hasil kompilasi $  $.a. Untuk melakukan ini, gunakan opsi $  $--cached: \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \$  $ git rm --cached readme.txt \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont Anda dapat menambahkan nama berkas, direktori, dan pola glob ke perintah $  $git rm. Ini berarti Anda dapat melakukan hal seperti \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \$  $ git rm log/ $  \setminus  $*.log \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont Perhatikan karakter backslash ( $  \setminus  $) di depan tanda $  $*. Ini dibutuhkan agar Git juga meng-ekspansi nama berkas sebagai tambahan dari ekspansi nama berkas oleh shell Anda. Perintah ini mengapus semua berkas yang memiliki ekstensi $  $.log $  $di dalam direktori $  $log/. Atau, Anda dapat melakukannya seperti ini: \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \$  $ git rm  $  \setminus  $* $  \sim  $ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont Perintah ini akan membuang semua berkas yang berakhiran dengan $  $ $  \sim  $. \\} \par
\vspace{14pt}
\subsection {Memindahkan berkas}
\noindent 
{\fontsize{14pt}{14pt}\selectfont Tidak seperti kebanyakan sistem VCS lainnya, Git tidak secara eksplisit memantau perpindahan berkas. Jika Anda mengubag nama berkas di Git, tidak ada metada yang tersimpan di Git yang menyatakan bahwa Anda mengubah nama berkas tersebut. Namun demikian, Git cukup cerdas untuk menemukannya berdasarkan fakta yang ada - kita akan membicarakan tentang mendeteksi perpindahan berkas sebentar lagi. \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont Untuk itu agak membingungkan bahwa Git memiliki perintah $  $mv. Jika Anda hendak mengubah nama berkas di Git, Anda dapat menjalankan seperti berikut \\} \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \$  $ git mv file $  \_  $from file $  \_  $to \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont dan itu berjalan baik. Bahkan, jika Anda menjalankannya seperti ini kemudian melihat ke status, Anda akan melihat bahwa Git menganggapnya sebagai perintah pengubahan nama berkas. \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \$  $ git mv README.txt README \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \$  $ git status \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ On branch master \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ Your branch is ahead of 'origin/master' by 1 commit. \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ Changes to be committed: \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $~~ (use "git reset HEAD <file>..." to unstage) \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $~~~~~~~renamed:~~  README.txt -> README \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \#  $ \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont Namun sebetulnya hal ini serupa dengan menjalankan perintah-perintah berikut: \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \$  $ mv README.txt README \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \$  $ git rm README.txt \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont  $  \$  $ git add README \\} \par
\noindent 
{\fontsize{14pt}{14pt}\selectfont Git mengetahui secara implisit bahwa perubahan yang terjadi merupakan proses pengubahan nama, sehingga sebetulnya tidaklah terlalu bermasalah jika Anda mengubah nama sebuah berkas dengan cara ini atau dengan menggunakan perintah $  $mv. Satu-satunya perbedaan utama adalah $  $mv $  $berjumlah satu perintah dan bukannya tiga - yang membuat fungsi ini lebih nyaman digunakan. Lebih penting lagi, Anda sebetulnya dapat menggunakan alat apapun yang Anda suka untuk mengubah nama berkas, tinggal tambahkan perintah add/rm di bagian akhir, sesaat sebelum Anda melakukan commit. \\} \par
\vspace{14pt}
\vspace{14pt}
\vspace{14pt}
\vspace{14pt}
\vspace{14pt}