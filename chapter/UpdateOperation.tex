\ref{git.jpg}:
\begin{figure}[ht]
	\centerline{\includegraphics[width=10cm,height=7cm]{Figures/pic.jpg}}
	\caption{learn git}
	\label{git.jpg}
\end{figure}

Git adalah version control system yang digunakan para developer untuk 
mengembangkan software secara bersama-bersama. Fungsi utama git yaitu 
mengatur versi dari source code program anda dengan mengasih tanda baris 
dan code mana yang ditambah atau diganti.
\vspace{12pt}

Git ini sebenernya memudahkan programmer untuk mengetahui perubahan 
source codenya daripada harus membuat file baru seperti Program.java, 
ProgramRevisi.java, ProgramRevisi2.java, ProgramFix.java. Selain itu, 
dengan git kita tak perlu khawatir code yang kita kerjakan bentrok, 
karena setiap developer bias membuat branch sebagai workspacenya.Fitur 
yang tak kalah keren lagi, pada git kita bisa memberi komentar pada 
source code yang telah ditambah/diubah, hal ini mempermudah developer 
lain untuk tahu kendala apa yang dialami developer lain.
\vspace{12pt}
Untuk mengetahui bagaimana menggunakan git, berikut perintah-perintah 
dasar git:

\newcounter{numberedCntE}
\begin{enumerate}
\item Git init : untuk membuat repository pada file lokal yang nantinya 
ada folder .git
\item Git status : untuk mengetahui status dari repository lokal
\item Git add : menambahkan file baru pada repository yang dipilih
\item Git commit : untuk menyimpan perubahan yang dilakukan, tetapi 
tidak ada perubahan pada remote repository.
\item Git push : untuk mengirimkan perubahan file setelah di commit ke 
remote repository.
\item Git branch : melihat seluruh branch yang ada pada repository
\item Git checkout : menukar branch yang aktif dengan branchyang dipilih
\item GIt merge : untuk menggabungkan branch yang aktif dan branch yang 
dipilih
\item Git clone : membuat Salinan repository lokal
\setcounter{numberedCntE}{\theenumi}
\end{enumerate}
Contoh dari software version control system adalah github, bitbucket, 
snowy evening, dan masih banyak lagi. Jika anda sebagai developer belum 
mengetahui fitur git ini, maka anda wajib mencoba dan memakainya. Karena 
banyak manfaat yang akan didapat dengan git ini.
\vspace{12pt}

Dalam melakukan pemrograman, perubahan spesifikasi atau kebutuhan adalah 
hal yang tidak dapat dihindari. Tidak ada program yang dapat dituliskan 
dengan sempurna pada percobaan pertama. Hal ini menyebabkan pengembang 
perangkat lunak sangat dekat dengan sistem kontrol versi, baik secara 
manual maupun menggunakan perangkat lunak khusus. Seri tulisan ini akan 
membahas tentang sistem kontrol versi, kegunaannya, serta contoh kasus 
menggunakan git, salah satu perangkat lunak populer untuk kontrol versi.

\section{Dasar Kontrol Versi}

Kegunaan utama dari sistem kontrol versi ialah sebagai alat untuk 
manajemen kode program. Terdapat dua kegunaan utama dari sistem ini, 
yaitu:

\newcounter{numberedCntC}
\begin{enumerate}
\item Menyimpan versi lama dari kode, maupun
\item Menggabungkan perubahan-perubahan kode dari versi lama (misal: 
untuk mengembalikan fitur yang telah dihapus) ataupun menggabungkan 
perubahan dari orang lain (misal: menggabungkan fitur yang dikembangkan 
oleh anggota tim lain).
\setcounter{numberedCntC}{\theenumi}
\end{enumerate}
Tanpa menggunakan sistem kontrol versi, yang sering saya temukan (dan 
dulunya saya gunakan, sebelum mengetahui tentang kontrol versi) ialah 
pengunaan direktori untuk memisahkan beberapa versi program.
\vspace{12pt}
Sistem kontrol versi, seperti git, hg, atau bzr, dikembangkan untuk 
menyelesaikan masalah-masalah di atas. Karena tidak ingin membahas 
terlalu banyak, artikel ini hanya akan menjelaskan pengunaan git, karena 
kelihatannya git merupakan perangkat lunak kontrol versi yang paling 
populer untuk sekarang (mengingat popularitas Github dan pengunaan git 
pada kernel Linux).
\vspace{12pt}


\subsection{Git}

Git adalah sebuah perangkat lunak untuk mengontrol versi sebuah 
perangkat lunak "VCS/Version Control System". Git diciptakan oleh Linux 
Torvalds, yang pada awalnya ditujukan untuk pengembangan kernel Linux. 
Saat ini banyak perangkat lunak yang terkenal menggunakan Git sebagai 
pengotrol revisinya.
\vspace{12pt}
Pada bab ini akan mempelajari bagaimana cara menggunakan Git seperti 
proses life cycle Git, operasi-operasi dasar dan bagaimana cara 
menangani masalah saat menggunakan Git.
\vspace{12pt}
Git menyimpan sementara perubahan yang telah di buat pada copy-an 
pekerjaan Anda sehingga Anda dapat mengerjakan sesuatu yang lain, lalu 
kembali dan terapkan kembali nanti. Stashing berguna jika Anda perlu 
mengubah konteks dan mengerjakan hal lain dengan lebih cepat, tapi Anda 
sedang melewati perubahan kode dan tidak cukup siap untuk melakukannya. 
\vspace{12pt}
Perintah git stash mengambil perubahan yang tidak terikat (baik yang 
dipasang maupun yang tidak terpasang), menyimpannya untuk penggunaan 
selanjutnya, lalu mengembalikannya dari salinan pekerjaan Anda. Sebagai 
contoh:
\vspace{12pt}
\begin{verbatim}

\$ git status

On branch master

Changes to be committed:

new file: style.css

Changes not staged for commit:

modified: index.html

\$ git stash

Saved working directory and index state WIP on master: 5002d47 our new 
homepage

HEAD is now at 5002d47 our new homepage

\$ git status

On branch master

nothing to commit, working tree clean
\end{verbatim}

Pada poin ini Anda bebas melakukan perubahan, membuat commit baru, 
mengganti cabang, dan melakukan operasi Git lainnya; Kemudian kembali 
dan pasang kembali simpanan Anda saat Anda siap.
\vspace{12pt}
\newcounter{numberedCntD}
\begin{enumerate}
\item Perhatikan bahwa simpanannya adalah lokal ke tempat penyimpanan 
Git Anda. 
\item Mengajukan kembali perubahan tersimpan Anda
\item Anda dapat mengajukan permohonan kembali sebelumnya menyimpan 
perubahan dengan git stash pop:
\setcounter{numberedCntD}{\theenumi}
\end{enumerate}

\begin{verbatim}
\$ git status

On branch master

nothing to commit, working tree clean

\$ git stash pop

On branch master

Changes to be committed:

new file: style.css

Changes not staged for commit:

modified: index.html

Dropped refs/stash@\{0\} (32b3aa1d185dfe6d57b3c3cc3b32cbf3e380cc6a)
\end{verbatim}

Memindahkan simpanan Anda akan menghilangkan perubahan dari simpanan 
Anda dan memasangnya kembali ke salinan pekerjaan Anda.



Sebagai alternatif, Anda dapat mengajukan permohonan kembali perubahan 
pada copy pekerjaan Anda dan menyimpannya di tempat penyimpanan dengan 
git stash berlaku:

\begin{verbatim}
\$ git stash apply

On branch master

Changes to be committed:

new file: style.css

Changes not staged for commit:

modified: index.html

\end{verbatim}


Ini berguna jika Anda ingin menerapkan perubahan tersimpan yang sama ke 
beberapa cabang.

Sekarang setelah Anda mengetahui dasar-dasar stashing, ada satu 
peringatan dengan penyimpanan git yang perlu Anda sadari: Secara default 
Git tidak akan menyimpan perubahan yang dibuat pada file yang tidak 
terlacak atau diabaikan.

\textbf{Menyembunyikan file yang tidak terlacak atau diabaikan}

Secara default, menjalankan git stash akan menyimpan:

\newcounter{numberedCntA}
\begin{enumerate}
\item perubahan yang telah ditambahkan ke indeks Anda (perubahan 
bertahap)
\item Perubahan yang dilakukan pada file yang saat ini dilacak oleh Git 
(perubahan yang tidak terhapus)
\setcounter{numberedCntA}{\theenumi}
\end{enumerate}
Tapi itu tidak akan disimpan:

\newcounter{numberedCntB}
\begin{enumerate}
\item file baru dalam copy pekerjaan Anda yang belum dipentaskan
\item file yang telah diabaikan
\setcounter{numberedCntB}{\theenumi}
\end{enumerate}
Jadi jika kita menambahkan file ketiga ke contoh kita di atas, tapi 
jangan tingkatkan (misal kita tidak menjalankan git add), git stash 
tidak akan menyimpannya.\vspace{12pt} 

\begin{verbatim}
\$ script.js

\$ git status

On branch master

Changes to be committed:

new file: style.css

Changes not staged for commit:

modified: index.html

Untracked files:

script.js

\$ git stash

Saved working directory and index state WIP on master: 5002d47 our new 
homepage

HEAD is now at 5002d47 our new homepage

\$ git status

On branch master

Untracked files:

script.js

\end{verbatim}

Menambahkan opsi -u (atau --include-unracked) memberitahu git stash 
untuk juga menyimpan file yang tidak terlacak.\vspace{12pt}



Jadi, sebenarnya apa yang dimaksud dengan Git? Ini adalah bagian penting 
untuk dipahami, karena jika anda memahami apa itu Git dan cara kerjanya, 
maka dapat dipastikan anda dapat menggunakan Git secara efektif dengan 
mudah. Selama mempelajari Git, cobalah untuk melupakan VCS lain yang 
mungkin telah anda kenal sebelumnya, misalnya Subversion dan Perforce. 
Git sangat berbeda dengan sistem-sistem tersebut dalam hal menyimpan dan 
memperlakukan informasi yang digunakan, walaupun antar-muka penggunanya 
hampir mirip. Dengan memahami perbedaan tersebut diharapkan dapat 
membantu anda menghindari kebingungan saat menggunakan Git.\vspace{12pt}

Salah satu perbedaan yang mencolok antar Git dengan VCS lainnya 
(Subversion dan kawan-kawan) adalah dalam cara Git memperlakukan 
datanya. Secara konseptual, kebanyakan sistem lain menyimpan informasi 
sebagai sebuah daftar perubahan berkas. Sistem seperti ini (CVS, 
Subversion, Bazaar, dan yang lainnya) memperlakukan informasi yang 
disimpannya sebagai sekumpulan berkas dan perubahan yang terjadi pada 
berkas-berkas tersebut.\vspace{12pt}

Git memperlakukan datanya sebagai sebuah kumpulan snapshot dari sebuah 
miniatur sistem berkas. Setiap kali anda melakukan commit, atau 
melakukan perubahan pada proyek Git anda, pada dasarnya Git merekam 
gambaran keadaan berkas-berkas anda pada saat itu dan menyimpan 
referensi untuk gambaran tersebut. Agar efisien, jika berkas tidak 
mengalami perubahan, Git tidak akan menyimpan berkas tersebut melainkan 
hanya pada file yang sama yang sebelumnya telah disimpan.\vspace{12pt}

Ini adalah sebuah perbedaan penting antara Git dengan hampir semua VCS 
lain. Hal ini membuat Git mempertimbangkan kembali hampir setiap aspek 
dari version control yang oleh kebanyakan sistem lainnya disalin dari 
generasi sebelumnya. Ini membuat Git lebih seperti sebuah miniatur 
sistem berkas dengan beberapa tool yang luar biasa ampuh yang dibangun 
di atasnya, ketimbang sekadar sebuah VCS. Kita akan mempelajari beberapa 
manfaat yang anda dapatkan dengan memikirkan data anda dengan cara ini 
ketika kita membahas "Git branching" pada Bab 3.\vspace{12pt}

\textbf{Hampir Semua Operasi Dilakukan Secara Lokal}\vspace{12pt}

Kebanyakan operasi pada Git hanya membutuhkan berkas-berkas dan resource 
lokal - tidak ada informasi yang dibutuhkan dari komputer lain pada 
jaringan anda. Jika Anda terbiasa dengan VCS terpusat dimana kebanyakan 
operasi memiliki overhead latensi jaringan, aspek Git satu ini akan 
membuat anda berpikir bahwa para dewa kecepatan telah memberkati Git 
dengan kekuatan. Karena anda memiliki seluruh sejarah dari proyek di 
lokal disk anda, dengan kebanyakan operasi yang tampak hampir seketika.\vspace{12pt}

Sebagai contoh, untuk melihat history dari proyek, Git tidak membutuhkan 
data histori dari server untuk kemudian menampilkannya untuk anda, namun 
secara sedarhana Git membaca historinya langsung dari basisdata lokal 
proyek tersebut. Ini berarti anda melihat histori proyek hampir secara 
instant. Jika anda ingin membandingkan perubahan pada sebuah berkas 
antara versi saat ini dengan versi sebulan yang lalu, Git dapat mencari 
berkas yang sama pada sebulan yang lalu dan melakukan pembandingan 
perubahan secara lokal, bukan dengan cara meminta remote server 
melakukannya atau meminta server mengirimkan berkas versi yang lebih 
lama kemudian membandingkannya secara lokal.\vspace{12pt}

Hal ini berarti bahwa sangat sedikit yang tidak bisa anda kerjakan jika 
anda sedang offline atau berada diluar VPN. Jika anda sedang berada 
dalam pesawat terbang atau sebuah kereta dan ingin melakukan pekerjaan 
kecil, anda dapat melakukan commit sampai anda memperoleh koneksi 
internet hingga anda dapat menguploadnya. Jika anda pulang ke rumah dan 
VPN client anda tidak bekerja dengan benar, anda tetap dapat bekerja. 
Pada kebanyakan sistem lainnya, melakukan hal ini cukup sulit atau 
bahkan tidak mungkin sama sekali. Pada Perforce misalnya, anda tidak 
dapat berbuat banyak ketika anda tidak terhubung dengan server; pada 
Subversion dan CVS, anda dapat mengubah berkas, tapi anda tidak dapat 
melakukan commit pada basisdata anda (karena anda tidak terhubung dengan 
basisdata). Hal ini mungkin saja bukanlah masalah yang besar, namun anda 
akan terkejut dengan perbedaan besar yang disebabkannya.\vspace{12pt}

\textbf{Git Memiliki Integritas}\vspace{12pt}

Segala sesuatu pada Git akan melalui proses checksum terlebih dahulu 
sebelum disimpan yang kemudian direferensikan oleh hasil checksum 
tersebut. Hal ini berarti tidak mungkin melakukan perubahan terhadap 
berkas manapun tanpa diketahui oleh Git. Fungsionalitas ini dimiliki 
oleh Git pada level terendahnya dan ini merupakan bagian tak terpisahkan 
dari filosofi Git. Anda tidak akan kehilangan informasi atau mendapatkan 
file yang cacat tanpa diketahui oleh Git.\vspace{12pt}

Mekanisme checksum yang digunakan oleh Git adalah SHA-1 hash. Ini 
merupakan sebuah susunan string yang terdiri dari 40 karakter 
heksadesimal (0 hingga 9 dan a hingga f) dan dihitung berdasarkan isi 
dari sebuah berkas atau struktur direktori pada Git.\vspace{12pt}

\subsubsection{Secara Umum Git Hanya Menambahkan Data}\vspace{12pt}
Ketika anda melakukan operasi pada Git, kebanyakan dari operasi tersebut 
hanya menambahkan data pada basisdata Git. It is very difficult to get 
the system to do anything that is not undoable or to make it erase data 
in any way. Seperti pada berbagai VCS, anda dapat kehilangan atau 
mengacaukan perubahan yang belum di-commit; namun jika anda melakukan 
commit pada Git, akan sangat sulit kehilanngannya, terutama jika anda 
secara teratur melakukan push basisdata anda pada repositori lain.\vspace{12pt}

Hal ini menjadikan Git menyenangkan karena kita dapat berexperimen tanpa 
kehawatiran untuk mengacaukan proyek. Untuk lebih jelas dan dalam lagi 
tentang bagaimana Git menyimpan datanya dan bagaimana anda dapat 
mengembalikan yang hilang, lihat "Under the Covers" pada Bab 9.\vspace{12pt}

\subsubsection{Tiga Keadaan}\vspace{12pt}
Sekarang perhatikan. Ini adalah hal utama yang harus diingat tentang Git 
jika anda ingin proses belajar anda berjalan lancar. Git memiliki 3 
keadaan utama dimana berkas anda dapat berada: committed, modified dan 
staged. Committed berarti data telah tersimpan secara aman pada 
basisdata lokal. Modified berarti anda telah melakukan perubahan pada 
berkas namun anda belum melakukan commit pada basisdata. Staged berarti 
anda telah menandai berkas yang telah diubah pada versi yang sedang 
berlangsung untuk kemudian dilakukan commit.\vspace{12pt}

Direktori Git adalah dimana Git menyimpan metadata dan database objek 
untuk projek anda. Ini adalah bahagian terpenting dari Git, dan inilah 
yang disalin ketika anda melakukan kloning sebuah repository dari 
komputer lain.\vspace{12pt}

Direktori kerja adalah sebuah checkout tunggal dari satu versi dari 
projek. Berkas-berkas ini kemudian ditarik keluar dari basisdata yang 
terkompresi dalam direktori Git dan disimpan pada disk untuk anda 
gunakan atau modifikasi.\vspace{12pt}

Staging area adalah sebuah berkas sederhana, umumnya berada dalam 
direktori Git anda, yang menyimpan informasi mengenai apa yang menjadi 
commit selanjutnya. Ini terkadang disebut sebagai index, tetapi semakin 
menjadi standard untuk menyebutnya sebagai staging area.\vspace{12pt}

\begin{table}[ht]
	\caption{Alur kerja dasar git}
	\centering
	\begin{tabular}{cccc}
		\hline
		No&Keterangan&\\
		\hline
		.1&Mengubah berkas dalam direktori kerja&\\
		.2&Menambahkan snapshotnya ke staging 
		area&\\
		.3&Commit,Ambil berkas di 
		staging area dan menyimpan snapshotnya ke direktori Git&\\
		\hline
	\end{tabular}
\end{table}

Jika sebuah versi tertentu dari sebuah berkas telah ada di direktori 
git, ia dianggap 'committed'. Jika berkas diubah (modified) tetapi sudah 
ditambahkan ke staging area, maka itu adalah 'staged'. Dan jika berkas 
telah diubah sejak terakhir dilakukan checked out tetapi belum 
ditambahkan ke staging area maka itu adalah 'modified'. Pada Bab 2, anda 
akan mempelajari lebih lanjut mengenai keadaan-keadaan ini dan bagaimana 
anda dapat memanfaatkan keadaan-keadaan tersebut ataupun melewatkan 
bagian 'staged' seluruhnya.\vspace{12pt}

\textbf{Modifikasi Fungsi yang Ada}\vspace{12pt}

Tom melakukan operasi kloning dan menemukan file baru string.c. Dia 
ingin tahu siapa yang menambahkan file ini ke repositori dan untuk 
tujuan apa, maka, dia menjalankan perintah git log.\vspace{12pt}

[$tom@CentOS ]~$ git clone gituser@git.server.com:project.git\vspace{12pt}

Perintah di atas akan menghasilkan hasil sebagai berikut:\vspace{12pt}

Initialized empty Git repository in /home/tom/project/.git/

remote: Counting objects: 6, done.

remote: Compressing objects: 100\% (4/4), done.

Receiving objects: 100\% (6/6), 726 bytes, done.

remote: Total 6 (delta 0), reused 0 (delta 0)\vspace{12pt}

Operasi Clone akan membuat direktori baru di dalam direktori kerja saat 
ini. Dia mengubah direktori ke direktori yang baru dibuat dan 
menjalankan perintah git log.\vspace{12pt}

[$tom@CentOS ~$] cd project/

[$tom@CentOS project ~$]git log\vspace{12pt}

Perintah di atas akan menghasilkan hasil sebagai berikut:\vspace{12pt}

commit d1e19d316224cddc437e3ed34ec3c931ad803958

Author: Jerry Mouse $<$jerry@tutorialspoint.com$>$

Date: Wed Sep 11 08:05:26 2013 +0530

Changed return type of my\_strlen to size\_t

commit 19ae20683fc460db7d127cf201a1429523b0e319

Author: Tom Cat $<$tom@tutorialspoint.com$>$

Date: Wed Sep 11 07:32:56 2013 +0530

Initial commit\vspace{12pt}

Setelah mengamati log, dia menyadari bahwa file string.c ditambahkan 
oleh Jerry untuk mengimplementasikan operasi string dasar. Dia penasaran 
dengan kode Jerry. Jadi dia membuka string.c di editor teks dan langsung 
menemukan bug. Dalam fungsi my\_strlen, Jerry tidak menggunakan pointer 
konstan. Jadi, dia memutuskan untuk memodifikasi kode Jerry. Setelah 
modifikasi, kode tersebut terlihat seperti berikut:\vspace{12pt}

$[$tom@CentOS project$]$\$ git diff\vspace{12pt}

Perintah di atas akan menghasilkan hasil sebagai berikut:\vspace{12pt}

diff --git a/string.c b/string.c

index 7da2992..32489eb 100644
\begin{equation}
--- a/string.c
\end{equation}

+++ b/string.c

@@ -1,8 +1,8 @@

\#include $<$stdio.h$>$

-size\_t my\_strlen(char *s)

+size\_t my\_strlen(const char *s)

\{

 - char *p = s;

 + const char *p = s;

 while (*p)

 ++p;

\}\vspace{12pt}

Setelah melakukan pengujian, dia menyimpan perubahannya.\vspace{12pt}
[$tom@CentOS project ~$] git status -s
M string.c
?? string

[$tom@CentOS project ~$] git add string.c

[$tom@CentOS project ~$] git commit -m 'Changed char pointer to const char pointer'
[master cea2c00] Changed char pointer to const char pointer
1 files changed, 2 insertions(+), 2 deletions(-)

[$tom@CentOS project ~$] git log\vspace{12pt}

perintah diatas akan menghasilkan hasil sebagai berikut:\vspace{12pt}

commit cea2c000f53ba99508c5959e3e12fff493b
Author: Tom Cat <tom@tutorialspoint.com>
Date: Wed Sep 11 08:32:07 2013 +0530

Changed char pointer to const char pointer


commit d1e19d316224cddc437e3ed34ec3c931ad803958

Author: Jerry Mouse $<$jerry@tutorialspoint.com$>$

Date: Wed Sep 11 08:05:26 2013 +0530

Changed return type of my\_strlen to size\_t

commit 19ae20683fc460db7d127cf201a1429523b0e319

Author: Tom Cat $<$tom@tutorialspoint.com$>$

Date: Wed Sep 11 07:32:56 2013 +0530

Initial commit\vspace{12pt}

Tom menggunakan git push untuk melakukan push atas perubahan yang dilakukannya.\par
\vspace{12pt}


[$tom@CentOS project ~$] git push origin master\par
\vspace{12pt}
perintah diatas akan menghasilkan seperti berikut:\par
\vspace{12pt}
Counting objects: 5, done.\par
\vspace{12pt}
Compressing objects: 100% (3/3), done.\par
\vspace{12pt}
Writing objects: 100% (3/3), 336 bytes, done.\par
\vspace{12pt}
Total 3 (delta 1), reused 0 (delta 0)\par
\vspace{12pt}
To gituser@git.server.com:project.git\par
\vspace{12pt}
d1e19d3..cea2c00 master âˆ’> master\par



